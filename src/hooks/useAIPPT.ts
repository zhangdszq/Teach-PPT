import { ref } from 'vue'
import { nanoid } from 'nanoid'
import type { ImageClipDataRange, PPTElement, PPTImageElement, PPTShapeElement, PPTTextElement, Slide, TextType } from '@/types/slides'
import type { AIPPTSlide } from '@/types/AIPPT'
import { useSlidesStore } from '@/store'
import useAddSlidesOrElements from './useAddSlidesOrElements'
import useSlideHandler from './useSlideHandler'
import { aiImageService } from '@/services/aiImageService'
import message from '@/utils/message'

interface ImgPoolItem {
  id: string
  src: string
  width: number
  height: number
}

export default () => {
  const slidesStore = useSlidesStore()
  const { addSlidesFromData } = useAddSlidesOrElements()
  const { isEmptySlide } = useSlideHandler()

  const imgPool = ref<ImgPoolItem[]>([])
  const transitionIndex = ref(0)
  const transitionTemplate = ref<Slide | null>(null)

  // ÂõæÁâáÁîüÊàêÈòüÂàóÁõ∏ÂÖ≥Áä∂ÊÄÅ
  const isGeneratingImages = ref(false)
  const imageGenerationProgress = ref(0)
  const totalImageCount = ref(0)
  const processedImageCount = ref(0)
  const imageGenerationQueue = ref<Array<{
    slideId: string
    elementId: string
    prompt: string
    element: PPTImageElement
  }>>([])

  const checkTextType = (el: PPTElement, type: TextType) => {
    return (el.type === 'text' && el.textType === type) || (el.type === 'shape' && el.text && el.text.type === type)
  }
  
  const getUseableTemplates = (templates: Slide[], n: number, type: TextType) => {
    if (n === 1) {
      const list = templates.filter(slide => {
        const items = slide.elements.filter(el => checkTextType(el, type))
        const titles = slide.elements.filter(el => checkTextType(el, 'title'))
        const texts = slide.elements.filter(el => checkTextType(el, 'content'))
  
        return !items.length && titles.length === 1 && texts.length === 1
      })
  
      if (list.length) return list
    }
  
    let target: Slide | null = null
  
    const list = templates.filter(slide => {
      const len = slide.elements.filter(el => checkTextType(el, type)).length
      return len >= n
    })
    if (list.length === 0) {
      const sorted = templates.sort((a, b) => {
        const aLen = a.elements.filter(el => checkTextType(el, type)).length
        const bLen = b.elements.filter(el => checkTextType(el, type)).length
        return aLen - bLen
      })
      target = sorted[sorted.length - 1]
    }
    else {
      target = list.reduce((closest, current) => {
        const currentLen = current.elements.filter(el => checkTextType(el, type)).length
        const closestLen = closest.elements.filter(el => checkTextType(el, type)).length
        return (currentLen - n) <= (closestLen - n) ? current : closest
      })
    }
  
    return templates.filter(slide => {
      const len = slide.elements.filter(el => checkTextType(el, type)).length
      const targetLen = target!.elements.filter(el => checkTextType(el, type)).length
      return len === targetLen
    })
  }
  
  const getAdaptedFontsize = ({
    text,
    fontSize,
    fontFamily,
    width,
    maxLine,
  }: {
    text: string
    fontSize: number
    fontFamily: string
    width: number
    maxLine: number
  }) => {
    const canvas = document.createElement('canvas')
    const context = canvas.getContext('2d')!
  
    let newFontSize = fontSize
    const minFontSize = 10
  
    while (newFontSize >= minFontSize) {
      context.font = `${newFontSize}px ${fontFamily}`
      const textWidth = context.measureText(text).width
      const line = Math.ceil(textWidth / width)
  
      if (line <= maxLine) return newFontSize
  
      const step = newFontSize <= 22 ? 1 : 2
      newFontSize = newFontSize - step
    }
  
    return minFontSize
  }
  
  const getFontInfo = (htmlString: string) => {
    const fontSizeRegex = /font-size:\s*(\d+(?:\.\d+)?)\s*px/i
    const fontFamilyRegex = /font-family:\s*['"]?([^'";]+)['"]?\s*(?=;|>|$)/i
  
    const defaultInfo = {
      fontSize: 16,
      fontFamily: 'Microsoft Yahei',
    }
  
    const fontSizeMatch = htmlString.match(fontSizeRegex)
    const fontFamilyMatch = htmlString.match(fontFamilyRegex)
  
    return {
      fontSize: fontSizeMatch ? (+fontSizeMatch[1].trim()) : defaultInfo.fontSize,
      fontFamily: fontFamilyMatch ? fontFamilyMatch[1].trim() : defaultInfo.fontFamily,
    }
  }
  
  const getNewTextElement = ({
    el,
    text,
    maxLine,
    longestText,
    digitPadding,
  }: {
    el: PPTTextElement | PPTShapeElement
    text: string
    maxLine: number
    longestText?: string
    digitPadding?: boolean
  }): PPTTextElement | PPTShapeElement => {
    const padding = 10
    const width = el.width - padding * 2 - 2
  
    let content = el.type === 'text' ? el.content : el.text!.content
  
    const fontInfo = getFontInfo(content)
    const size = getAdaptedFontsize({
      text: longestText || text,
      fontSize: fontInfo.fontSize,
      fontFamily: fontInfo.fontFamily,
      width,
      maxLine,
    })
  
    const parser = new DOMParser()
    const doc = parser.parseFromString(content, 'text/html')
  
    const treeWalker = document.createTreeWalker(doc.body, NodeFilter.SHOW_TEXT)
  
    const firstTextNode = treeWalker.nextNode()
    if (firstTextNode) {
      if (digitPadding && firstTextNode.textContent && firstTextNode.textContent.length === 2 && text.length === 1) {
        firstTextNode.textContent = '0' + text
      }
      else firstTextNode.textContent = text
    }
  
    if (doc.body.innerHTML.indexOf('font-size') === -1) {
      const p = doc.querySelector('p')
      if (p) p.style.fontSize = '16px'
    }
  
    content = doc.body.innerHTML.replace(/font-size:(.+?)px/g, `font-size: ${size}px`)
  
    return el.type === 'text' ? { ...el, content, lineHeight: size < 15 ? 1.2 : el.lineHeight } : { ...el, text: { ...el.text!, content } }
  }

  const getUseableImage = (el: PPTImageElement): ImgPoolItem | null => {
    let img: ImgPoolItem | null = null
  
    let imgs = []
  
    if (el.width === el.height) imgs = imgPool.value.filter(img => img.width === img.height)
    else if (el.width > el.height) imgs = imgPool.value.filter(img => img.width > img.height)
    else imgs = imgPool.value.filter(img => img.width <= img.height)
    if (!imgs.length) imgs = imgPool.value
  
    img = imgs[Math.floor(Math.random() * imgs.length)]
    imgPool.value = imgPool.value.filter(item => item.id !== img!.id)
  
    return img
  }
  
  const getNewImgElement = (el: PPTImageElement): PPTImageElement => {
    const img = getUseableImage(el)
    if (!img) return el
  
    let scale = 1
    let w = el.width
    let h = el.height
    let range: ImageClipDataRange = [[0, 0], [0, 0]]
    const radio = el.width / el.height
    if (img.width / img.height >= radio) {
      scale = img.height / el.height
      w = img.width / scale
      const diff = (w - el.width) / 2 / w * 100
      range = [[diff, 0], [100 - diff, 100]]
    }
    else {
      scale = img.width / el.width
      h = img.height / scale
      const diff = (h - el.height) / 2 / h * 100
      range = [[0, diff], [100, 100 - diff]]
    }
    const clipShape = (el.clip && el.clip.shape) ? el.clip.shape : 'rect'
    const clip = { range, shape: clipShape }
    const src = img.src
  
    return { ...el, src, clip }
  }
  
  const getMdContent = (content: string) => {
    const regex = /```markdown([^```]*)```/
    const match = content.match(regex)
    if (match) return match[1].trim()
    return content.replace('```markdown', '').replace('```', '')
  }
  
  const getJSONContent = (content: string) => {
    const regex = /```json([^```]*)```/
    const match = content.match(regex)
    if (match) return match[1].trim()
    return content.replace('```json', '').replace('```', '')
  }

  const presetImgPool = (imgs: ImgPoolItem[]) => {
    imgPool.value = imgs
  }

  /**
   * Ê∑ªÂä†ÂõæÁâáÂà∞ÁîüÊàêÈòüÂàó
   */
  const addToImageQueue = (slideId: string, elementId: string, prompt: string, element: PPTImageElement) => {
    imageGenerationQueue.value.push({
      slideId,
      elementId,
      prompt,
      element
    })
  }

  /**
   * Â§ÑÁêÜÂõæÁâáÁîüÊàêÈòüÂàó
   * @param concurrency Âπ∂ÂèëÊï∞ÔºåÈªòËÆ§‰∏∫2
   */
  const processImageQueue = async (concurrency: number = 2) => {
    // Â¶ÇÊûúÈòüÂàó‰∏∫Á©∫ÔºåÁõ¥Êé•ËøîÂõû
    if (imageGenerationQueue.value.length === 0) {
      console.log('‚ö†Ô∏è ÈòüÂàó‰∏∫Á©∫ÔºåÊó†ÈúÄÂ§ÑÁêÜ')
      return
    }

    // Â¶ÇÊûúÊ≠£Âú®ÁîüÊàêÂõæÁâáÔºåÁõ¥Êé•ËøîÂõûÔºåÈÅøÂÖçÈáçÂ§çÂ§ÑÁêÜ
    if (isGeneratingImages.value) {
      console.log('‚è≥ Ê£ÄÊµãÂà∞Ê≠£Âú®ÁîüÊàêÂõæÁâáÔºåÂΩìÂâçÈòüÂàóÂ∞ÜË¢´ÂêàÂπ∂Â§ÑÁêÜ')
      return
    }

    console.log(`üöÄ ÂºÄÂßãÂ§ÑÁêÜÂõæÁâáÁîüÊàêÈòüÂàóÔºåÂÖ± ${imageGenerationQueue.value.length} ‰∏™‰ªªÂä°`)
    
    isGeneratingImages.value = true
    totalImageCount.value = imageGenerationQueue.value.length
    processedImageCount.value = 0
    imageGenerationProgress.value = 0

    let currentLoadingMessage = message.success(
      `Ê≠£Âú®‰∏∫ ${totalImageCount.value} ‰∏™ÂõæÁâáÂÖÉÁ¥†ÁîüÊàêAIÂõæÁâáÔºåËØ∑Á®çÂÄô...`,
      { duration: 0 }
    )
    
    // ËÆ∞ÂΩïÂºÄÂßãÊó∂Èó¥
    const startTime = Date.now()

    // ÂàõÂª∫ËøõÂ∫¶Êõ¥Êñ∞ÂÆöÊó∂Âô®
    const progressTimer = setInterval(() => {
      if (currentLoadingMessage && processedImageCount.value < totalImageCount.value) {
        currentLoadingMessage.close()
        const progress = Math.round((processedImageCount.value / totalImageCount.value) * 100)
        const elapsedTime = Math.floor((Date.now() - startTime) / 1000)
        const estimatedTotal = totalImageCount.value > 0 ? Math.floor(elapsedTime / processedImageCount.value * totalImageCount.value) : 0
        const remainingTime = Math.max(0, estimatedTotal - elapsedTime)
        
        let timeStr = ''
        if (remainingTime > 60) {
          const minutes = Math.floor(remainingTime / 60)
          const seconds = remainingTime % 60
          timeStr = ` (È¢ÑËÆ°Ââ©‰Ωô ${minutes}ÂàÜ${seconds}Áßí)`
        } else if (remainingTime > 0) {
          timeStr = ` (È¢ÑËÆ°Ââ©‰Ωô ${remainingTime}Áßí)`
        }
        
        currentLoadingMessage = message.success(
          `Ê≠£Âú®ÁîüÊàêÂõæÁâá ${processedImageCount.value}/${totalImageCount.value} (${progress}%)${timeStr}`,
          { duration: 0 }
        )
        imageGenerationProgress.value = progress
      }
    }, 1000)

    try {
      // Â§çÂà∂ÈòüÂàóÔºå‰ΩÜ‰∏çÁ´ãÂç≥Ê∏ÖÁ©∫ÂéüÈòüÂàóÔºåÁ≠âÂ§ÑÁêÜÂÆåÊàêÂêéÂÜçÊ∏ÖÁ©∫
      const queue = [...imageGenerationQueue.value]
      console.log(`üìã Â§çÂà∂ÈòüÂàóÂÆåÊàêÔºåÂºÄÂßãÂàÜÊâπÂ§ÑÁêÜÔºåÂπ∂ÂèëÊï∞: ${concurrency}`)

      let successCount = 0
      let failureCount = 0

      // ÂàÜÊâπÂ§ÑÁêÜÔºåÊØèÊâπÂπ∂ÂèëÂ§ÑÁêÜÊåáÂÆöÊï∞Èáè
      for (let i = 0; i < queue.length; i += concurrency) {
        const batch = queue.slice(i, i + concurrency)
        const batchNumber = Math.floor(i / concurrency) + 1
        const totalBatches = Math.ceil(queue.length / concurrency)
        console.log(`üîÑ Â§ÑÁêÜÁ¨¨ ${batchNumber}/${totalBatches} ÊâπÔºåÂåÖÂê´ ${batch.length} ‰∏™‰ªªÂä°`)
        
        // Âπ∂ÂèëÂ§ÑÁêÜÂΩìÂâçÊâπÊ¨°
        const batchPromises = batch.map(async (item, batchIndex) => {
          const globalIndex = i + batchIndex + 1
          
          // Êü•ÊâæÂπªÁÅØÁâáÁ¥¢Âºï‰ª•‰æøÂú®ËøõÂ∫¶‰∏≠ÊòæÁ§∫
          const slideIndex = slidesStore.slides.findIndex(s => s.id === item.slideId) + 1
          
          try {
            console.log('============================================')
            console.log(`üñºÔ∏è [${globalIndex}/${queue.length}] ÂºÄÂßãÁîüÊàêÂõæÁâá`)
            console.log(`üìç ‰ΩçÁΩÆ: Á¨¨ ${slideIndex} Âº†ÂπªÁÅØÁâá`)
            console.log(`üéØ ÁõÆÊ†á: ÂπªÁÅØÁâáID: ${item.slideId}, ÂÖÉÁ¥†ID: ${item.elementId}`)
            console.log(`üí¨ ÊèêÁ§∫ËØç: "${item.prompt}"`)
            
            const success = await generateImageForElement(item.element, item.prompt, item.slideId, item.elementId)
            processedImageCount.value++
            
            if (success) {
              successCount++
              console.log(`‚úÖ [${globalIndex}/${queue.length}] ÂõæÁâáÁîüÊàêÊàêÂäü!`)
            }
            else {
              failureCount++
              console.log(`‚ùå [${globalIndex}/${queue.length}] ÂõæÁâáÁîüÊàêÂ§±Ë¥•`)
            }
            
            return { success, item, index: globalIndex, slideIndex }
          }
          catch (error) {
            processedImageCount.value++
            failureCount++
            console.error(`‚ùå [${globalIndex}/${queue.length}] ÂõæÁâáÁîüÊàêÂºÇÂ∏∏:`, error)
            return { success: false, item, error, index: globalIndex, slideIndex }
          }
        })

        const batchResults = await Promise.allSettled(batchPromises)
        console.log(`üìä Á¨¨ ${Math.floor(i / concurrency) + 1} ÊâπÂ§ÑÁêÜÂÆåÊàêÔºåÁªìÊûú:`, batchResults.map(r => r.status))
        
        // Â¶ÇÊûú‰∏çÊòØÊúÄÂêé‰∏ÄÊâπÔºåÁ®çÂæÆÂª∂ËøüÈÅøÂÖçËØ∑Ê±ÇËøá‰∫éÂØÜÈõÜ
        if (i + concurrency < queue.length) {
          // Ê†πÊçÆÂ§±Ë¥•ÁéáÂä®ÊÄÅË∞ÉÊï¥Âª∂Ëøü
          const failureRate = failureCount / (successCount + failureCount)
          const delay = failureRate > 0.3 ? 2000 : 500 // Â§±Ë¥•ÁéáÈ´ò‰∫é30%Êó∂Â¢ûÂä†Âª∂Ëøü
          await new Promise(resolve => setTimeout(resolve, delay))
        }
      }

      // Â§ÑÁêÜÂÆåÊàêÂêéÊ∏ÖÁ©∫Â∑≤Â§ÑÁêÜÁöÑÈòüÂàó
      imageGenerationQueue.value = []
      console.log(`üéä ÂΩìÂâçÊâπÊ¨°Â§ÑÁêÜÂÆåÊàê! ÊàêÂäü: ${successCount}, Â§±Ë¥•: ${failureCount}`)
      
      console.log(`‚ú® ÊâÄÊúâÂõæÁâáÁîüÊàê‰ªªÂä°Â∑≤ÂÆåÊàê!`)

      // Ê∏ÖÈô§ËøõÂ∫¶ÂÆöÊó∂Âô®
      clearInterval(progressTimer)

      // ÂÖ≥Èó≠loadingÊ∂àÊÅØ
      if (currentLoadingMessage) {
        currentLoadingMessage.close()
      }

      // ËÆ°ÁÆóÊÄªËÄóÊó∂
      const totalTime = Math.floor((Date.now() - startTime) / 1000)
      const timeStr = totalTime > 60 ? 
        `${Math.floor(totalTime / 60)}ÂàÜ${totalTime % 60}Áßí` : 
        `${totalTime}Áßí`
      
      // ÊòæÁ§∫ÂÆåÊàêÊ∂àÊÅØ
      if (successCount > 0) {
        message.success(`ÊàêÂäüÁîüÊàê ${successCount} Âº†AIÂõæÁâáÔºÅ${failureCount > 0 ? ` (${failureCount} Âº†Â§±Ë¥•)` : ''} ËÄóÊó∂${timeStr}`)
      }
      else if (failureCount > 0) {
        message.error(`ÂõæÁâáÁîüÊàêÂ§±Ë¥•ÔºåÂÖ± ${failureCount} Âº†ÂõæÁâáÊú™ËÉΩÁîüÊàê`)
      }

    }
    catch (error) {
      console.error('‚ùå ÊâπÈáèÁîüÊàêÂõæÁâáÂ§±Ë¥•:', error)
      clearInterval(progressTimer)
      if (currentLoadingMessage) {
        currentLoadingMessage.close()
      }
      message.error('ÂõæÁâáÁîüÊàêËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØ: ' + (error as Error).message)
    }
    finally {
      isGeneratingImages.value = false
      processedImageCount.value = 0
      totalImageCount.value = 0
      imageGenerationProgress.value = 0
      console.log('üîö ÂõæÁâáÁîüÊàêÈòüÂàóÂ§ÑÁêÜÁªìÊùü')
    }
  }

  /**
   * ‰∏∫Âçï‰∏™ÂõæÁâáÂÖÉÁ¥†ÁîüÊàêAIÂõæÁâá
   * @param element ÂõæÁâáÂÖÉÁ¥†
   * @param prompt AIÁîüÊàêÊèêÁ§∫ËØç
   * @param targetSlideId ÁõÆÊ†áÂπªÁÅØÁâáID
   * @param targetElementId ÁõÆÊ†áÂÖÉÁ¥†ID
   * @param retryCount ÂΩìÂâçÈáçËØïÊ¨°Êï∞
   * @param maxRetries ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞
   */
  const generateImageForElement = async (
    element: PPTImageElement, 
    prompt: string, 
    targetSlideId: string, 
    targetElementId: string,
    retryCount: number = 0,
    maxRetries: number = 2
  ): Promise<boolean> => {
    try {
      console.log(`üé® ÂºÄÂßã‰∏∫ÂÖÉÁ¥† ${targetElementId} ÁîüÊàêÂõæÁâáÔºåÊèêÁ§∫ËØç: "${prompt}"`)
      console.log(`üéØ ÁõÆÊ†áÂπªÁÅØÁâá: ${targetSlideId}`)
      console.log(`üìê ÂõæÁâáÂ∞∫ÂØ∏: ${element.width || 800}x${element.height || 600}`)
      
      // ËÆæÁΩÆË∂ÖÊó∂ÔºàÊ†πÊçÆÈáçËØïÊ¨°Êï∞Â¢ûÂä†Ë∂ÖÊó∂Êó∂Èó¥Ôºâ
      const timeout = 30000 + (retryCount * 10000) // 30Áßí + ÊØèÊ¨°ÈáçËØï10Áßí
      
      // ‰ΩøÁî®Áªü‰∏ÄÁöÑ AI ÂõæÁâáÁîüÊàêÊúçÂä°
      const response = await aiImageService.generateImage({
        prompt,
        model: 'jimeng',
        width: element.width || 800,
        height: element.height || 600
      })
      
      if (!response.success || !response.imageUrl) {
        throw new Error(response.error || 'ÂõæÁâáÁîüÊàêÂ§±Ë¥•')
      }
      
      const imageUrl = response.imageUrl
      
      if (imageUrl) {
        console.log(`üîÑ Êõ¥Êñ∞ÂÖÉÁ¥† ${targetElementId} ÁöÑÂõæÁâáURL: ${imageUrl}`)
        console.log(`üéØ ÁõÆÊ†áÂπªÁÅØÁâáID: ${targetSlideId}`)
        
        // È™åËØÅÁõÆÊ†áÂπªÁÅØÁâáÂíåÂÖÉÁ¥†ÊòØÂê¶Â≠òÂú®
        const targetSlide = slidesStore.slides.find(slide => slide.id === targetSlideId)
        if (!targetSlide) {
          console.error(`‚ùå Êú™ÊâæÂà∞ÁõÆÊ†áÂπªÁÅØÁâá: ${targetSlideId}`)
          return false
        }
        
        const targetElement = targetSlide.elements.find(el => el.id === targetElementId)
        if (!targetElement) {
          console.error(`‚ùå Âú®ÂπªÁÅØÁâá ${targetSlideId} ‰∏≠Êú™ÊâæÂà∞ÂÖÉÁ¥†: ${targetElementId}`)
          console.log('üîç ËØ•ÂπªÁÅØÁâáÁöÑÊâÄÊúâÂÖÉÁ¥†ID:', targetSlide.elements.map(el => el.id))
          return false
        }
        
        // Á≤æÁ°ÆÊõ¥Êñ∞ÊåáÂÆöÂπªÁÅØÁâá‰∏≠ÁöÑÊåáÂÆöÂÖÉÁ¥†
        slidesStore.updateElement({
          id: targetElementId,
          props: { src: imageUrl },
          slideId: targetSlideId
        })
        
        console.log(`‚úÖ ÂÖÉÁ¥† ${targetElementId} Âú®ÂπªÁÅØÁâá ${targetSlideId} ‰∏≠ÂõæÁâáÊõ¥Êñ∞ÊàêÂäü`)
        console.log(`üñºÔ∏è ÂõæÁâáURL: ${imageUrl}`)
        return true
      }
      
      throw new Error('Êú™Ëé∑ÂèñÂà∞ÂõæÁâáURL')
    }
    catch (error: any) {
      console.error(`‚ùå ‰∏∫ÂÖÉÁ¥† ${targetElementId} ÁîüÊàêÂõæÁâáÂ§±Ë¥•:`, error)
      console.error(`‚ùå Â§±Ë¥•ÁöÑÊèêÁ§∫ËØç: "${prompt}"`)
      console.error(`‚ùå ÈîôËØØËØ¶ÊÉÖ:`, error)
      
      // Âà§Êñ≠ÊòØÂê¶ÂèØ‰ª•ÈáçËØï
      const isRetryableError = 
        error.message?.includes('timeout') ||
        error.message?.includes('network') ||
        error.message?.includes('HTTP 5') ||
        error.message?.includes('HTTP 429') || // Rate limit
        error.code === 'ECONNRESET' ||
        error.code === 'ETIMEDOUT'
      
      if (isRetryableError && retryCount < maxRetries) {
        const retryDelay = Math.min(1000 * Math.pow(2, retryCount), 5000) // ÊåáÊï∞ÈÄÄÈÅøÔºåÊúÄÂ§ö5Áßí
        console.log(`üîÑ Â∞ÜÂú® ${retryDelay}ms ÂêéÈáçËØïÁ¨¨ ${retryCount + 1}/${maxRetries} Ê¨°...`)
        
        await new Promise(resolve => setTimeout(resolve, retryDelay))
        
        // ÈÄíÂΩíÈáçËØï
        return generateImageForElement(
          element, 
          prompt, 
          targetSlideId, 
          targetElementId, 
          retryCount + 1, 
          maxRetries
        )
      }
      
      // ‰∏çÈáçÊñ∞ÊäõÂá∫ÈîôËØØÔºåËÄåÊòØËøîÂõûfalseÔºåËÆ©Ë∞ÉÁî®ÊñπÂ§ÑÁêÜ
      return false
    }
  }

  /**
   * Êî∂ÈõÜÂπªÁÅØÁâá‰∏≠ÈúÄË¶ÅAIÁîüÊàêÂõæÁâáÁöÑÂÖÉÁ¥†Âπ∂Ê∑ªÂä†Âà∞ÈòüÂàó
   * ÊîØÊåÅ‰ªéÊï¥‰∏™slides storeÊàñÊåáÂÆöÁöÑÂπªÁÅØÁâáÊï∞ÁªÑÊî∂ÈõÜ
   */
  const collectAndQueueImages = (slides?: Slide[]) => {
    // Â¶ÇÊûúÊ≤°Êúâ‰º†ÂÖ•slidesÔºå‰ªéstoreËé∑ÂèñÊâÄÊúâÂπªÁÅØÁâá
    const targetSlides = slides || slidesStore.slides
    console.log('üîç ÂºÄÂßãÊî∂ÈõÜÂõæÁâáÂÖÉÁ¥†ÔºåÂπªÁÅØÁâáÊï∞Èáè:', targetSlides.length)
    
    // Ê∏ÖÁ©∫Áé∞ÊúâÈòüÂàó
    imageGenerationQueue.value = []
    
    let totalImageElements = 0
    let skippedElements = 0
    
    targetSlides.forEach((slide, slideIndex) => {
      console.log('============================================')
      console.log(`üìÑ Ê£ÄÊü•Á¨¨ ${slideIndex + 1} Âº†ÂπªÁÅØÁâá (ID: ${slide.id})ÔºåÂÖÉÁ¥†Êï∞Èáè: ${slide.elements.length}`)
      
      const imageElements = slide.elements.filter(el => el.type === 'image')
      totalImageElements += imageElements.length
      console.log(`üñºÔ∏è ÊâæÂà∞ ${imageElements.length} ‰∏™ÂõæÁâáÂÖÉÁ¥†`)
      
      imageElements.forEach((element, elementIndex) => {
        const imgElement = element as PPTImageElement
        console.log(`üîç Ê£ÄÊü•ÂõæÁâáÂÖÉÁ¥† ${elementIndex + 1}:`, {
          id: imgElement.id,
          type: imgElement.type,
          hasAlt: !!imgElement.alt,
          alt: imgElement.alt,
          hasSrc: !!imgElement.src,
          src: imgElement.src?.substring(0, 50) + '...'
        })
        
        // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅAIÁîüÊàêÂõæÁâáÁöÑÊù°‰ª∂Ôºö
        // 1. ÂøÖÈ°ªÊúâaltÂ±ûÊÄß‰∏î‰∏ç‰∏∫Á©∫
        // 2. alt‰∏çÊòØÁâπÊÆäÊ†áËÆ∞ÔºàÂ¶ÇREMOVE_THIS_ELEMENTÔºâ
        // 3. ÂèØÈÄâÔºöÊ£ÄÊü•ÊòØÂê¶Â∑≤ÊúâÊúâÊïàÁöÑsrcÔºàÂèØÈÖçÁΩÆÊòØÂê¶ÈáçÊñ∞ÁîüÊàêÔºâ
        const hasValidAlt = imgElement.alt && imgElement.alt.trim() && imgElement.alt !== 'REMOVE_THIS_ELEMENT'
        const hasValidSrc = imgElement.src && !imgElement.src.includes('placeholder') && !imgElement.src.includes('default') && !imgElement.src.startsWith('data:image/svg')
        
        // Âè™Ë¶ÅÊúâÊúâÊïàÁöÑaltÂ∞±Âä†ÂÖ•ÈòüÂàóÔºàÂç≥‰ΩøÂ∑≤ÊúâsrcÔºå‰πüÂèØËÉΩÈúÄË¶ÅÊõ¥Êñ∞Ôºâ
        const needsAIGeneration = hasValidAlt
        
        if (needsAIGeneration) {
          console.log(`‚úÖ Ê∑ªÂä†Âà∞AIÁîüÊàêÈòüÂàó: "${imgElement.alt}" (${hasValidSrc ? 'Â∞ÜÊõøÊç¢Áé∞ÊúâÂõæÁâá' : 'Êñ∞ÂõæÁâá'})`)
          addToImageQueue(slide.id, imgElement.id, imgElement.alt!.trim(), imgElement)
        }
        else {
          skippedElements++
          console.log(`‚ùå Ë∑≥ËøáÂõæÁâáÂÖÉÁ¥†ÔºåÂéüÂõ†:`, {
            hasValidAlt,
            alt: imgElement.alt || '(Êó†altÂ±ûÊÄß)',
            reason: !imgElement.alt ? 'Áº∫Â∞ëaltÂ±ûÊÄß' : 
                   !imgElement.alt.trim() ? 'altÂ±ûÊÄß‰∏∫Á©∫' : 
                   imgElement.alt === 'REMOVE_THIS_ELEMENT' ? 'ÁâπÊÆäÊ†áËÆ∞ÂÖÉÁ¥†' : 'ÂÖ∂‰ªñ'
          })
        }
      })
    })
    
    // Êõ¥Êñ∞ÊÄªÊï∞ËÆ°Êï∞Âô®
    totalImageCount.value = imageGenerationQueue.value.length
    processedImageCount.value = 0
    
    console.log('============================================')
    console.log(`üìä Êî∂ÈõÜÂÆåÊàêÁªüËÆ°:`)
    console.log(`  - ÊÄªÂπªÁÅØÁâáÊï∞: ${targetSlides.length}`)
    console.log(`  - ÊÄªÂõæÁâáÂÖÉÁ¥†Êï∞: ${totalImageElements}`)
    console.log(`  - ÈúÄË¶ÅÁîüÊàêÁöÑÂõæÁâáÊï∞: ${imageGenerationQueue.value.length}`)
    console.log(`  - Ë∑≥ËøáÁöÑÂõæÁâáÊï∞: ${skippedElements}`)
    console.log(`  - ÈòüÂàóËØ¶ÊÉÖ:`, imageGenerationQueue.value.map(item => ({
      slide: item.slideId,
      element: item.elementId,
      prompt: item.prompt
    })))
  }

  /**
   * ÂêØÂä®ÂõæÁâáÁîüÊàêÈòüÂàóÂ§ÑÁêÜ
   */
  const startImageGeneration = async () => {
    console.log(`üé¨ ÂêØÂä®ÂõæÁâáÁîüÊàêÈòüÂàóÂ§ÑÁêÜÔºåÂΩìÂâçÈòüÂàóÈïøÂ∫¶: ${imageGenerationQueue.value.length}`)
    
    if (imageGenerationQueue.value.length === 0) {
      console.log('üì≠ ÈòüÂàó‰∏∫Á©∫ÔºåÊó†ÈúÄÂêØÂä®Â§ÑÁêÜ')
      return
    }
    
    if (!isGeneratingImages.value) {
      console.log(`üöÄ Á´ãÂç≥ÂºÄÂßãÂ§ÑÁêÜ ${imageGenerationQueue.value.length} ‰∏™ÂõæÁâáÁîüÊàê‰ªªÂä°`)
      await processImageQueue(2) // ÊØèÊ¨°Âπ∂ÂèëÂ§ÑÁêÜ2‰∏™ÂõæÁâá
    } else {
      console.log('‚è≥ Ê£ÄÊµãÂà∞Ê≠£Âú®ÁîüÊàêÂõæÁâáÔºåÊñ∞‰ªªÂä°Â∞ÜÂú®ÂΩìÂâç‰ªªÂä°ÂÆåÊàêÂêéÂ§ÑÁêÜ')
    }
  }

  const AIPPT = (templateSlides: Slide[], _AISlides: AIPPTSlide[], imgs?: ImgPoolItem[]) => {
    slidesStore.updateSlideIndex(slidesStore.slides.length - 1)

    if (imgs) imgPool.value = imgs

    const AISlides: AIPPTSlide[] = []
    for (const template of _AISlides) {
      if (template.type === 'content') {
        const items = template.data.items
        if (items.length === 5 || items.length === 6) {
          const items1 = items.slice(0, 3)
          const items2 = items.slice(3)
          AISlides.push({ ...template, data: { ...template.data, items: items1 } })
          AISlides.push({ ...template, data: { ...template.data, items: items2 }, offset: 3 })
        }
        else if (items.length === 7 || items.length === 8) {
          const items1 = items.slice(0, 4)
          const items2 = items.slice(4)
          AISlides.push({ ...template, data: { ...template.data, items: items1 } })
          AISlides.push({ ...template, data: { ...template.data, items: items2 }, offset: 4 })
        }
        else if (items.length === 9 || items.length === 10) {
          const items1 = items.slice(0, 3)
          const items2 = items.slice(3, 6)
          const items3 = items.slice(6)
          AISlides.push({ ...template, data: { ...template.data, items: items1 } })
          AISlides.push({ ...template, data: { ...template.data, items: items2 }, offset: 3 })
          AISlides.push({ ...template, data: { ...template.data, items: items3 }, offset: 6 })
        }
        else if (items.length > 10) {
          const items1 = items.slice(0, 4)
          const items2 = items.slice(4, 8)
          const items3 = items.slice(8)
          AISlides.push({ ...template, data: { ...template.data, items: items1 } })
          AISlides.push({ ...template, data: { ...template.data, items: items2 }, offset: 4 })
          AISlides.push({ ...template, data: { ...template.data, items: items3 }, offset: 8 })
        }
        else {
          AISlides.push(template)
        }
      }
      else if (template.type === 'contents') {
        const items = template.data.items
        if (items.length === 11) {
          const items1 = items.slice(0, 6)
          const items2 = items.slice(6)
          AISlides.push({ ...template, data: { ...template.data, items: items1 } })
          AISlides.push({ ...template, data: { ...template.data, items: items2 }, offset: 6 })
        }
        else if (items.length > 11) {
          const items1 = items.slice(0, 10)
          const items2 = items.slice(10)
          AISlides.push({ ...template, data: { ...template.data, items: items1 } })
          AISlides.push({ ...template, data: { ...template.data, items: items2 }, offset: 10 })
        }
        else {
          AISlides.push(template)
        }
      }
      else AISlides.push(template)
    }

    const coverTemplates = templateSlides.filter(slide => slide.type === 'cover')
    const contentsTemplates = templateSlides.filter(slide => slide.type === 'contents')
    const transitionTemplates = templateSlides.filter(slide => slide.type === 'transition')
    const contentTemplates = templateSlides.filter(slide => slide.type === 'content')
    const endTemplates = templateSlides.filter(slide => slide.type === 'end')

    if (!transitionTemplate.value) {
      const _transitionTemplate = transitionTemplates[Math.floor(Math.random() * transitionTemplates.length)]
      transitionTemplate.value = _transitionTemplate
    }

    const slides = []
    
    for (const item of AISlides) {
      if (item.type === 'cover') {
        const coverTemplate = coverTemplates[Math.floor(Math.random() * coverTemplates.length)]
        const elements = coverTemplate.elements.map(el => {
          if (el.type === 'image' && el.imageType && imgPool.value.length) return getNewImgElement(el)
          if (el.type !== 'text' && el.type !== 'shape') return el
          if (checkTextType(el, 'title') && item.data.title) {
            return getNewTextElement({ el, text: item.data.title, maxLine: 1 })
          }
          if (checkTextType(el, 'content') && item.data.text) {
            return getNewTextElement({ el, text: item.data.text, maxLine: 3 })
          }
          return el
        })
        slides.push({
          ...coverTemplate,
          id: nanoid(10),
          elements,
        })
      }
      else if (item.type === 'contents') {
        const _contentsTemplates = getUseableTemplates(contentsTemplates, item.data.items.length, 'item')
        const contentsTemplate = _contentsTemplates[Math.floor(Math.random() * _contentsTemplates.length)]

        const sortedNumberItems = contentsTemplate.elements.filter(el => checkTextType(el, 'itemNumber'))
        const sortedNumberItemIds = sortedNumberItems.sort((a, b) => {
          if (sortedNumberItems.length > 6) {
            let aContent = ''
            let bContent = ''
            if (a.type === 'text') aContent = a.content
            if (a.type === 'shape') aContent = a.text!.content
            if (b.type === 'text') bContent = b.content
            if (b.type === 'shape') bContent = b.text!.content

            if (aContent && bContent) {
              const aIndex = parseInt(aContent)
              const bIndex = parseInt(bContent)

              return aIndex - bIndex
            }
          }
          const aIndex = a.left + a.top * 2
          const bIndex = b.left + b.top * 2
          return aIndex - bIndex
        }).map(el => el.id)

        const sortedItems = contentsTemplate.elements.filter(el => checkTextType(el, 'item'))
        const sortedItemIds = sortedItems.sort((a, b) => {
          if (sortedItems.length > 6) {
            const aItemNumber = sortedNumberItems.find(item => item.groupId === a.groupId)
            const bItemNumber = sortedNumberItems.find(item => item.groupId === b.groupId)

            if (aItemNumber && bItemNumber) {
              let aContent = ''
              let bContent = ''
              if (aItemNumber.type === 'text') aContent = aItemNumber.content
              if (aItemNumber.type === 'shape') aContent = aItemNumber.text!.content
              if (bItemNumber.type === 'text') bContent = bItemNumber.content
              if (bItemNumber.type === 'shape') bContent = bItemNumber.text!.content
  
              if (aContent && bContent) {
                const aIndex = parseInt(aContent)
                const bIndex = parseInt(bContent)
  
                return aIndex - bIndex
              }
            }
          }

          const aIndex = a.left + a.top * 2
          const bIndex = b.left + b.top * 2
          return aIndex - bIndex
        }).map(el => el.id)

        const longestText = item.data.items.reduce((longest, current) => current.length > longest.length ? current : longest, '')

        const unusedElIds: string[] = []
        const unusedGroupIds: string[] = []
        const elements = contentsTemplate.elements.map(el => {
          if (el.type === 'image' && el.imageType && imgPool.value.length) return getNewImgElement(el)
          if (el.type !== 'text' && el.type !== 'shape') return el
          if (checkTextType(el, 'item')) {
            const index = sortedItemIds.findIndex(id => id === el.id)
            const itemTitle = item.data.items[index]
            if (itemTitle) return getNewTextElement({ el, text: itemTitle, maxLine: 1, longestText })

            unusedElIds.push(el.id)
            if (el.groupId) unusedGroupIds.push(el.groupId)
          }
          if (checkTextType(el, 'itemNumber')) {
            const index = sortedNumberItemIds.findIndex(id => id === el.id)
            const offset = item.offset || 0
            return getNewTextElement({ el, text: index + offset + 1 + '', maxLine: 1, digitPadding: true })
          }
          return el
        }).filter(el => !unusedElIds.includes(el.id) && !(el.groupId && unusedGroupIds.includes(el.groupId)))
        slides.push({
          ...contentsTemplate,
          id: nanoid(10),
          elements,
        })
      }
      else if (item.type === 'transition') {
        transitionIndex.value = transitionIndex.value + 1
        const elements = transitionTemplate.value.elements.map(el => {
          if (el.type === 'image' && el.imageType && imgPool.value.length) return getNewImgElement(el)
          if (el.type !== 'text' && el.type !== 'shape') return el
          if (checkTextType(el, 'title') && item.data.title) {
            return getNewTextElement({ el, text: item.data.title, maxLine: 1 })
          }
          if (checkTextType(el, 'content') && item.data.text) {
            return getNewTextElement({ el, text: item.data.text, maxLine: 3 })
          }
          if (checkTextType(el, 'partNumber')) {
            return getNewTextElement({ el, text: transitionIndex.value + '', maxLine: 1, digitPadding: true })
          }
          return el
        })
        slides.push({
          ...transitionTemplate.value,
          id: nanoid(10),
          elements,
        })
      }
      else if (item.type === 'content') {
        const _contentTemplates = getUseableTemplates(contentTemplates, item.data.items.length, 'item')
        const contentTemplate = _contentTemplates[Math.floor(Math.random() * _contentTemplates.length)]

        const sortedTitleItemIds = contentTemplate.elements.filter(el => checkTextType(el, 'itemTitle')).sort((a, b) => {
          const aIndex = a.left + a.top * 2
          const bIndex = b.left + b.top * 2
          return aIndex - bIndex
        }).map(el => el.id)

        const sortedTextItemIds = contentTemplate.elements.filter(el => checkTextType(el, 'item')).sort((a, b) => {
          const aIndex = a.left + a.top * 2
          const bIndex = b.left + b.top * 2
          return aIndex - bIndex
        }).map(el => el.id)

        const sortedNumberItemIds = contentTemplate.elements.filter(el => checkTextType(el, 'itemNumber')).sort((a, b) => {
          const aIndex = a.left + a.top * 2
          const bIndex = b.left + b.top * 2
          return aIndex - bIndex
        }).map(el => el.id)

        const itemTitles = []
        const itemTexts = []

        for (const _item of item.data.items) {
          if (_item.title) itemTitles.push(_item.title)
          if (_item.text) itemTexts.push(_item.text)
        }
        const longestTitle = itemTitles.reduce((longest, current) => current.length > longest.length ? current : longest, '')
        const longestText = itemTexts.reduce((longest, current) => current.length > longest.length ? current : longest, '')

        const elements = contentTemplate.elements.map(el => {
          if (el.type === 'image' && el.imageType && imgPool.value.length) return getNewImgElement(el)
          if (el.type !== 'text' && el.type !== 'shape') return el
          if (item.data.items.length === 1) {
            const contentItem = item.data.items[0]
            if (checkTextType(el, 'content') && contentItem.text) {
              return getNewTextElement({ el, text: contentItem.text, maxLine: 6 })
            }
          }
          else {
            if (checkTextType(el, 'itemTitle')) {
              const index = sortedTitleItemIds.findIndex(id => id === el.id)
              const contentItem = item.data.items[index]
              if (contentItem && contentItem.title) {
                return getNewTextElement({ el, text: contentItem.title, longestText: longestTitle, maxLine: 1 })
              }
            }
            if (checkTextType(el, 'item')) {
              const index = sortedTextItemIds.findIndex(id => id === el.id)
              const contentItem = item.data.items[index]
              if (contentItem && contentItem.text) {
                return getNewTextElement({ el, text: contentItem.text, longestText, maxLine: 4 })
              }
            }
            if (checkTextType(el, 'itemNumber')) {
              const index = sortedNumberItemIds.findIndex(id => id === el.id)
              const offset = item.offset || 0
              return getNewTextElement({ el, text: index + offset + 1 + '', maxLine: 1, digitPadding: true })
            }
          }
          if (checkTextType(el, 'title') && item.data.title) {
            return getNewTextElement({ el, text: item.data.title, maxLine: 1 })
          }
          return el
        })
        slides.push({
          ...contentTemplate,
          id: nanoid(10),
          elements,
        })
      }
      else if (item.type === 'end') {
        const endTemplate = endTemplates[Math.floor(Math.random() * endTemplates.length)]
        const elements = endTemplate.elements.map(el => {
          if (el.type === 'image' && el.imageType && imgPool.value.length) return getNewImgElement(el)
          return el
        })
        slides.push({
          ...endTemplate,
          id: nanoid(10),
          elements,
        })
      }
    }
    
    // Ê∑ªÂä†ÂπªÁÅØÁâáÂà∞store
    if (isEmptySlide.value) slidesStore.setSlides(slides)
    else addSlidesFromData(slides)
    
    // Âú®ÊâÄÊúâÂπªÁÅØÁâáÊ∑ªÂä†ÂÆåÊàêÂêéÔºåÊî∂ÈõÜÂπ∂Â§ÑÁêÜÈúÄË¶ÅAIÁîüÊàêÁöÑÂõæÁâá
    console.log('üé® ÂºÄÂßãÂ§ÑÁêÜAIÂõæÁâáÁîüÊàêÈòüÂàó...')
    
    // Êî∂ÈõÜÊâÄÊúâÂ∏¶ÊúâaltÂ±ûÊÄßÁöÑÂõæÁâáÂÖÉÁ¥†
    collectAndQueueImages()
    
    // Â¶ÇÊûúÊúâÈúÄË¶ÅÁîüÊàêÁöÑÂõæÁâáÔºåÂêØÂä®ÂºÇÊ≠•ÁîüÊàêÊµÅÁ®ã
    if (imageGenerationQueue.value.length > 0) {
      console.log(`üöÄ Ê£ÄÊµãÂà∞ ${imageGenerationQueue.value.length} ‰∏™ÂõæÁâáÈúÄË¶ÅAIÁîüÊàêÔºåÂºÄÂßãÂ§ÑÁêÜ...`)
      // ÂºÇÊ≠•Â§ÑÁêÜÂõæÁâáÁîüÊàêÔºå‰∏çÈòªÂ°ûUI
      setTimeout(() => {
        startImageGeneration()
      }, 100)
    } else {
      console.log('üì∑ Ê≤°ÊúâÊ£ÄÊµãÂà∞ÈúÄË¶ÅAIÁîüÊàêÁöÑÂõæÁâá')
    }
  }

  return {
    presetImgPool,
    AIPPT,
    getMdContent,
    getJSONContent,
    // ÂõæÁâáÁîüÊàêÈòüÂàóÁõ∏ÂÖ≥
    isGeneratingImages,
    imageGenerationProgress,
    totalImageCount,
    processedImageCount,
    imageGenerationQueue,
    addToImageQueue,
    startImageGeneration,
    collectAndQueueImages,
  }
}